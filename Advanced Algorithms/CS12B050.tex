\documentclass[solution,addpoints,12pt]{exam}
\printanswers
\usepackage{amsmath,amssymb}
\usepackage[T1]{fontenc}
\begin{document}
\hrule
\vspace{3mm}
\noindent
{\sf IITM-CS6840-2015 : Advanced Algorithms  \hfill Given on: Feb 1}
\vspace{3mm} \\
\noindent
{\sf Problem Set \#1 \hfill Due on : Feb 15}
\vspace{3mm}
\hrule

\begin{questions}
\question
\begin{parts}
\part
Let the probability of H be p, therby probability of T is 1-p.
Consider the following experiment :\\
Toss the coin twice and consider HT as new H and TH as new T. If neither
of these happens, repeat the above.\\
Probability of new H = 1/4 + (1/2)*(1/4) + .... = 1/2.\\
Probability of new T = 1/4 + (1/2)*(1/4) + .... = 1/2.\\
Hence we get a uniform sample over new H and new T.\\
Expected tosses = 2*(1/2) + 4*(1/2*1/2) + 6*(1/2*1/2*1/2) .... \\
Therefore expected tosses = 1/(1-1/2) + 1/2*1/${(1-1/2)}^2$ = 4.\\
\end{parts}
\question
\begin{parts}
\part
Consider the following LP relaxation which relates to the problem in hand :\\
Have $x_i$ which denotes the $i^{th}$ vertex and $y_{ij}$ which
denotes the edge between vertex i and vertex j if one such exists.
Min $\Sigma x_i$ subject to :\\
$x_i + x_j \ge y_{ij}$.\\
$0 \le x_i \le 1$.\\
$0 \le y_{ij} \le 1$.\\
$\Sigma y_{ij} \ge t$ where t is the number of edges we want to cover.
Here we can see that the integer version of the LP exactly solves the t vertex cover
problem.
\part
Let us solve a harder problem which is as follows :\\
Find the maximum number of edges that k vertices can cover. Once we know this
we can repeatedly query for k from 1 to n and get the minimum vertices needed to
cover t edges.\\

Let us work out a DP approach to solve the above problem as follows :\\
Fix one vertex as the root (r).\\
Other than r for every vertex v in the tree consider two maps associated
with it called DP[v] and $DP_{parent-swap}$[v].\\
Basically $DP[v]$ represents the map from number of vertices to maximum number of edges
those many edges can cover when we look at the
sub-graph rooted at v, (ie) like \{0 : 0, 1 : 2, 2 : 4, 3 : 5, ...\}.\\
and $DP_{parent-swap}$ represents a similar map when the parent of the vertex
is seen as a leaf child of v added to the existing sub graph rooted at v.
We end the map once all the edges are covered by the vertices.
\\


Consider the following equation for DP[v] :\\
DP[v] = max(merge(
$DP_{parent-swap}[v'] \forall v'$ which are children of v),
merge($DP[v'] \forall v'$ which are children of v) + degree of v)
Basically if the map returns \{ 0 : 0, 1 : 4, 2 : 7 \} and the
degree of the current vertex is 3, then the
new map we form is \{ 0 : 0, 1 : 3, 2 : 7, 3 : 10 \} for the second merge we look at.

Merge of two maps basically means that we are making up the
map again for the union of the trees (ie) the forest comprising of the two trees.
The map will again store the information about what is the maximum number of edges
which can be covered by i vertices for all i less than or equal to number of vertices
in the subgraph rooted at v.
Applying merge for two maps repeatedly until 1 map is left, is the overall merge operation
which operates on all the maps of the children of a vertex v.\\

Merge for two maps M1, M2 works as follows (let M1 have k elements and M2 have l elements):\\
Let the new map be M3.\\
M3[k] = max(M1[i] + M2[j]) over all i,j such that i + j = k.\\
This would ensure that the two maps of the forests are combined to form the optimal map
for the union of these two forests.\\
Now we would repeatedly merge two forests until we get the optimal map of
union of the subtrees of all the children of the vertex v we are looking at.\\

max denotes a element wise max of the maps returned by both of the merges.
The worst case order for this step is (k+l)*k*l per merging of two maps and
hence order for overall merging is bounded by (k+l)*k*l*n which is bounded by $n^4$.
Hence the overall computing cost is 2*n*$n^4$ as we need to make two maps
for each node and hence it is polynomial time.\\

Now let us see why the DP works :\\
If all the trees rooted at children of a vertex v already have such maps,
then for creating the map for this vertex v, we have two choices : either
choosing the vertex v in the set or not choosing the vertex in the set. Now
if the vertex is not chosen somehow we need to give provision for the
edge between vertex v and child of the vertex which is made sure by the
parent swap we mentioned above. Hence once we make up the maps for
both of these cases, we can take the maximum per element in the map and we
can find the optimal map for the current vertex.

One side note :\\
Let the root vertex be v and some child of it be v'.\\
We would never have to pick the leaf node which we made (v swapped as child)
for any particular element of the map as instead of picking this vertex, we could
as well pick the parent of this leaf node (ie) (v') instead which is guaranteed
to cover atleast as much as before. If v' was already chosen, then choosing
this vertex is of no use as already the edge from this vertex is covered. Hence
the copy of v inroduced in each of the sub trees would never be chosen in
making up the maps and hence $DP_{parent-swapping}$ exactly captures the case
where the parent is not chosen.\\

Therefore finally we can reach the root of the tree and we could find the
optimal map. Hence the overall order is $O(n^5)$ and we would end up
finding the optimal map for the overall tree.\\
\end{parts}
\question
Let t be the minimum number of bipartite graphs the edges are split into and k be the
chromatic number of the graph G.\\
Let us prove that t = lif(log(k)).\\
\begin{itemize}
\item $k \le 2^t$ or $log(k) \le t$.\\
If a bipartite graph doesnot have a vertex at all, then simply put the vertex on
one side of the bipartite graph and donot emanate any edge from it. Therefore
all bipartite graphs will have all the vertices in it.\\
Consider the split up of the edges across t different bipartite graphs as follows :\\
Denote a number for each vertex for each bipartite split up as 0 on one side and
one on the other. Therefore any vertex can be represented with a t tuple
(ie) a t tuple of either 0 or 1 (0 or 1 for each bipartite splitup). If two
vertices have the same t tuple, then there could not have been an edge between
them because the bipartite split ups copletely cover all the edges. Hence colour
each vertex based on the tuple. That is for all vertex of the same tuple
give the same colour or that each tuple has its own colour.\\
Maximum number of tuples possible is $2^t$. Therefore we have a colouring
with $2^t$ colours and hence $k \le 2^t$.\\
\item $t \le lif(log(k))$.\\
Consider the base case where k = 2,\\
we can have only one bipartite graph, which can cover all the edges.\\
Let us assume the graph can be coloured with $2^p$ colours (p = log(k)).\\
Let us assume that till some p, $t \le p$.\\
Let the graph be coloured with $2^{p+1}$ colours, in that case,\\
then consider the following split up, have vertices coloured by $2^p$
of the colours on one side and vertices coloured by the other $2^p$ vertices
on the other side. Now we would not have covered the
edges of the sub graph of the original graph which contains the edges
$between$ the vertices coloured with $2^p$ colours in the first graph
or between the vertices coloured with $2^p$ colours in the second graph.
Let this graph be G'. There are no edges between the vertices
on one side of G and the other side of G in G'. Hence the same $2^p$ colours
can be used to colour each side of the graph seperately. Hence G' is $2^p$
colourable. By our induction assumption, G' can be split into
p bipartite graphs. Hence graph G is split into p+1 bipartite graphs.
Hence we are done.\\

Note : If chromatic number is not a power of 2, then round it to the
nearest 2 power greater than it and the above proof holds.
\end{itemize}
Therefore combining the above we get $t = lif(log(k))$.

\question
Decision version : Does there exists a minimum spanning tree with atleast k leaves? (Problem P)\\
Consider P' which is :\\
Does there exists a spanning tree with atleast k leaves?\\
Trivially P' is reducible to P as we can always make the graph unweighted.\\
Let us reduce the connected dominating set(P'') to P'. We know that the connected dominating
set problem is NP complete which would prove that P' is NP hard in turn proving that P
is NP hard.\\
Given input G and k : Output : Does there exists a connected dominating
set of size k ?\\
If there exists a spanning tree with n-k leaves, there exists a connected dominating
set of size k. Simply pick all the non leaf vertices.\\
If there exists connected dominating set of size k it means that we can there
exists an edge from each of the other n-k vertices to atleast one vertex in the dominating
set. Hence if we consider one such edge for each of the n-k vertices we would get a
spanning tree with n-k leaves.\\
Hence it is easy to see that the following reduction works :\\
P''(G, k) to P'(G, n-k).\\
Therefore P' is NP hard impying P is NP hard.\\
P is in NP as follows :\\
Pick the different edge sets possible using choice of an NP machine. At
each leaf compute the minimum spanning tree in polynomial time.
For each edge set, check whether the edges form a spanning tree and that the cost is the
same as that of the MST and whether the tree has k or more leaves. If it does accept
else reject. Therefore P is NP complete.
(P refers to Problem P and not Polynomial time (sorry for the confusion)).
\end{questions}

\end{document}
